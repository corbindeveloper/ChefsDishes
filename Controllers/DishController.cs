using System.Diagnostics;
using Microsoft.AspNetCore.Mvc;
using ChefsDishes.Models;
using Microsoft.EntityFrameworkCore;

namespace ChefsDishes.Controllers;

public class DishController : Controller
{
    private ChefsDishesContext _context;

    // here we can "inject" our context service into the constructor
    public DishController(ChefsDishesContext context)
    {
        _context = context;
    }

    // =====================================
    // ALL
    [HttpGet("/all/dishes")]
    public IActionResult AllDishes()
    {
        List<Dish> AllDishes = _context.Dishes.Include(dish => dish.Cook).ToList();

        return View("AllDishes", AllDishes);
    }

    // =====================================
    // NEW
    [HttpGet("/new/dish")]
    public IActionResult NewDish()
    {
        // ViewBag to bring over Chefs for select
        List<Chef> AllChefs = _context.Chefs.ToList();
        ViewBag.ListAllChefs = AllChefs;

        return View("NewDish");
    }

    // =====================================
    // CREATE
    [HttpPost("/create/dish")]
    public IActionResult CreateDish(Dish newDish)
    {
        if (ModelState.IsValid == false) {
            // by not defaulting the return of View() in New, we can invoke the New() function & not have to re-write code return View("New");

            return NewDish();
        }

        //this only runs if ModelState.IsValid == true
        _context.Dishes.Add(newDish);
        // our sql database doesn't update until we save changes
        // after calling SaveChanges, our newPost will now have a value stored in PostId that was automatically generated by our database
        _context.SaveChanges();

        return AllDishes();
    }

 }